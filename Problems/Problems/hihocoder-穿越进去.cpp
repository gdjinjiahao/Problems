/*
描述
作为H国的精英特工，你接到了一项任务，驾驶一辆吉普穿越布满监测雷达的禁区。为了简化题目，我们可以把禁区想象为一个左下角是(0, 0)右上角是( W, H )的长方形区域。区域中一共有 N 座雷达，其中第 i 座的坐标是(Xi, Yi )，监测范围是半径为 Ri 的圆形区域。所有在圆内和圆上的运载工具都会被监测到。

你的目标是从左到右穿越禁区。你可以选择线段(0, 0)-(0, H)上任意一点作为起点，线段(W, 0)-(W, H)上任意一点作为终点。在禁区内你可以沿任意路线行驶，只要保持始终在禁区内并且没有被雷达监测到。

给出禁区内的雷达部署方案，你需要判断是否存在满足条件的行驶路线。

输入
输入包含多组数据。

第1行是一个整数 T，表示以下有 T 组数据 (1 ≤ T ≤ 10)。

每组数据的第1行：三个整数 W, H, N (0 ≤ W, H ≤ 1000000, 1 ≤ N ≤ 1000)。

每组数据的第2-N+1行：每行三个整数Xi, Yi, Ri (0 ≤ Xi ≤ W, 0 ≤ Yi ≤ H, 1 ≤ Ri ≤ 1000000)。

输出
对于每组数据输出"YES"或者"NO"表示是否有满足条件的行驶路线。

样例输入
2
10 4 2
5 1 1
5 3 1
10 4 2
5 1 1
6 3 1
样例输出
NO
YES


分析：
题目大意：给定一个矩形区域，其中有一些圆形雷区。问是否存在一条从左边界移动到右边界的路线，并且中途不经过任何雷区(也不能接触雷区边缘)。起点可选在左边界任意一点，终点可选在右边界任意一点。

我们人脑会有一个很直观的判断，如果雷区没有把左边界和右边界分隔开的话，那么就一定有一条穿越的路线；否则如果左右边界被雷区隔开，那么就一定不存在穿越路线。

问题在于如何把我们脑内直观的判断转化成程序能进行的确定的判断。通过分析我们可以发现：

如果两个圆相切或者相交，那么它们的雷区会合并在一起
若干个圆连续相切或者相交，会形成一片连通的雷区
如果一片连通的雷区同时与上下边界相交或相切，那么这片雷区就会把左右边界分割开来；反之亦然


于是我们可以把原本的几何问题转化成一个图论问题。我们把每一个圆看作一个顶点，同时把上边界看作起点，下边界看作终点。如果两个圆或者圆与边界之间是相交或者相切的，我们就在代表两者的顶点之间连一条边。最后如果存在一条起点到终点的路径，那么就不存在从左到右的穿越路线；反之如果不存在起点到终点的路径，就存在从左到右的穿越路线。

所以第一步我们要做的是建图。这个图一共有N+2个顶点。每对顶点之间我们都要判断是否有边相连，也就是判断圆与圆以及圆与边界是否相交或相切。

这是个简单的计算几何问题。对于圆与圆来说，只需要判断圆心距和半径之和的大小关系；对于圆与边界来说，需要判断圆心到边界的距离和半径的关系，由于边界是平行于X轴的，所以只需要比较Y坐标就能求出圆心到边界的距离。

由于有(N+2)(N+1)/2条边要判断，第一步的复杂度是O(N^2)。

第二步是要判断是否有从起点到终点的路径。这一步我们可以用宽搜、深搜或者并查集来实现，复杂度也是O(N^2)的。
*/

#include <cstdio>
#include <cstring>
#include <string>
#include <algorithm>
#include <vector>
#include <queue>
#include <iostream>
#include <map>
#include <cmath>
using namespace std;

int w,h,n;

long long f[1010],up[1010],down[1010];
long long x[1010],y[1010],r[1010];

long long getf(int x)
{
	if(x==f[x]) return x;
	return f[x]=getf(f[x]);
}

bool isadj(int i,int j)
{
	return (x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j])<=(r[i]+r[j])*(r[i]+r[j]);
}

int main()
{
	//freopen("in.txt","r",stdin);
	int T;
	scanf("%d",&T);
	while(T--){
		scanf("%d%d%d",&w,&h,&n);
		for(int i=0;i<n;i++) f[i]=i;
		for(int i=0;i<n;i++){
			scanf("%lld%lld%lld",x+i,y+i,r+i);
			up[i]=y[i]+r[i];
			down[i]=y[i]-r[i];
		}

		for(int i=0;i<n;i++)
			for(int j=0;j<n;j++) if(isadj(i,j)){
				int fa=getf(i),fb=getf(j);
				if(fa==fb) continue;
	
				up[fa]=max(up[fa],up[fb]);
				down[fa]=min(down[fa],down[fb]);
				f[fb]=fa;
			}
	
		bool ans=true;
		for(int i=0;i<n;i++) if(i==f[i]){
			if(up[i]>=h&&down[i]<=0){
				ans=false;
				break;
			}
		}
		if(ans) printf("YES\n");
		else printf("NO\n");
	}
    return 0;
}